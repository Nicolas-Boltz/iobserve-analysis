package org.iobserve.analysis.correspondence;

import java.io.FileInputStream;

import javax.xml.bind.JAXB;

import protocom.extension.mapping.PcmMapping;

/**
 * Factory to create correspondence model instances according to RAC in paper 
 * <i>Run-time Architecture Models for Dynamic Adaptation and Evolution of Cloud Applications</i>
 * 
 * @author Robert Heinrich, Alessandro Giusa
 * @version 1.0
 *
 */
public final class CorrespondeceModelFactory {
	
	/**singleton instance of factory*/
	public static final CorrespondeceModelFactory INSTANCE = new CorrespondeceModelFactory();

	/**
	 * Simple constructor does nothing
	 */
	private CorrespondeceModelFactory() {
		// do nothing
	}
	
	/**
	 * 
	 * @param pathMappingFile
	 *            path to the mapping file generated by Protocom. It provides
	 *            the information how Protocom generated source code out of PCM components.
	 * @param mapper
	 *            this mapper is used to decide whether or not a method is correct based on the
	 *            provided operationSignature. Protocom produces wired method names, which can vary from
	 *            a lot from the original operation signature.
	 * @return a {@link Correspondent} instance representing the mapping file
	 */
	public ICorrespondence createCorrespondenceModel(final String pathMappingFile,
			final OperationSignatureSelector mapper) {
		final PcmMapping mapping = this.getMapping(pathMappingFile);
		final CorrespondenceModelImpl rac = new CorrespondenceModelImpl(mapping, mapper);
		rac.initMapping();
		return rac;
	}
	
	/**
	 * Read the mapping file and return the mapping model
	 * @param path
	 * @return
	 */
	private PcmMapping getMapping(final String path) {
		PcmMapping mapping = null;
		try {
			final FileInputStream input = new FileInputStream(path);
			mapping = JAXB.unmarshal(input, PcmMapping.class);
		} catch (final Exception e) {
			e.printStackTrace();
		}
		return mapping;
	}
	
	// **********************************************************************
	// Default implementations For OperationSignatureMapper
	// **********************************************************************

	/**
	 * Check the name of the method against the operation signature. Return true if the method name contains
	 * the operation signature name.
	 */
	public final OperationSignatureSelector DEFAULT_OPERATION_SIGNATURE_MAPPER = (method, operationSignature) ->
		method.getName().trim().replaceAll(" ", "").contains(operationSignature.getName().trim().replaceAll(" ", ""));

	/**
	 * Check the name of the method or the class against the operation signature. Return true if the method name or the class name contains
	 * the operation signature name.
	 */
	public final OperationSignatureSelector DEFAULT_OPERATION_SIGNATURE_MAPPER_2 = (method, operationSignature) ->
		method.getName().trim().replaceAll(" ", "").contains(operationSignature.getName().trim().replaceAll(" ", ""))
			|| method.getParent().getUnitName().toLowerCase().contains(operationSignature.getName().toLowerCase());
}
